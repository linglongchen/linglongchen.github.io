# 并发编程之线程池
作者： 陈汤姆
<br/>博客：[https://github.com/linglongchen/linglongchen.github.io](https://github.com/linglongchen/linglongchen.github.io)

>自我学习的积累！😄

## 概念
线程的创建和销毁
线程池中的线程是可以复用的，不需要每次执行异步任务时都创建和销毁线程


## 原理
- 线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。
- 核心思想就是将任务和线程两者解耦，不让两者直接关联

![77441586f6b312a54264e3fcf5eebe2663494.png](https://s2.loli.net/2024/08/27/g6x9fIFArzH5lTX.png)
## 线程池参数

- **corePoolSize**：核心线程数，线程池中保留一直运行的线程数；线程池没有任务可以执行时线程池不会主动销毁核心线程，如果设置allowCoreThreadTimeOut=true则没有线程时会主动回收
- **maximumPoolSize**：线程池允许的最大线程数，如果超过最大线程数则会将线程写入阻塞队列
- **keeyAliveTime**：线程池中的线程数超过核心线程数，并且为闲置状态时，允许存活的最大时间，超过这个时间线程会关闭。
- **TimeUnit**：存活时间的单位
- **workQueue**：线程的等待阻塞队列，，如果超过最大核心线程数，则线程会被放入阻塞队列中等待。
	- ArrayBlockQueue：有界阻塞队列
	- LinkedBlockQueue：默认长度为Integer.MAX_VALUE
	- DelayQueue：延迟无界队列
	- PriorityBlockQueue：优先级无界队列
	- SynchronousQueue：同步阻塞队列
- **RejectedExecutionHandler**：拒绝策略，线程池的阻塞队列满了执行的策略
	- - **AbortPolicy**：默认策略，丢掉任务并且抛出RejectedExecutionException异常
	- - **DiscardPolicy**：丢掉这个任务并且不会有任何异常
	- - **DiscardOldestPolicy**：将最早进入队列的任务删掉
	- - **CallerRunsPolicy**：如果添加到线程池失败，主线程会自己去执行该任务
	- - **自定义**：定义一个拒绝策略，实现RejectedExecutionHandler接口，并且实现rejectedExecution方法
- **ThreadFactory**：线程工厂，创建线程的工厂类，该工厂类可以继承然后自定义如何创建线程
![31bad766983e212431077ca8da92762050214.png](https://s2.loli.net/2024/08/27/5FHiSCO3TtALQYG.png)


## 线程池使用
- execute：提交任务无返回值
- submit：提交任务有返回值
- shutdown：关闭线程池，在finaly中关闭，并且要用try-catch包裹


## 线程池规范

### CPU密集型
**corePoolSize = CPU核数 + 1**

### IO密集型
**线程数=CPU核心数*(1+(IO等待时间/CPU计算时间))**





## 引用
https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html