# 计算机网络之拆包、粘包

作者： 陈汤姆
<br/>博客：[https://github.com/linglongchen/linglongchen.github.io](https://github.com/linglongchen/linglongchen.github.io)

>自我学习的积累！😄




## 粘包
由于TCP传输协议是面向字节流的传输协议，没有消息保护边界，所以发送方发送的多个数据包，接收方应用层不知如何区分，可能会被当成一个包来处理，这就是粘包。


### 原因
- 套接字缓冲区：TCP的发送方每次发送报文段，都希望能包含尽量多的字节，这样可以最大限度的利用网络带宽
- Nagle算法：使用Nagle算法时，会尽量地将一些小段凑成一个大段进行发送，而这就导致了粘包现象的发生

## 拆包
发送方将一个大包分成多个小包发送，而接收方将它们当成多个包进行处理，这就是拆包。

### 原因
- MTU 最大传输单元和 MSS 最大分段大小的限制：TCP为了能将数据发送出去，且每个报文中的数据不超过MSS，会将一个大的数据包分为多个小段，为每个段加上首部后逐一发送，而这就造成了拆包。
![po_diagram.png](https://s2.loli.net/2024/08/19/XzBwoL7rMgIVYlj.png)
- TCP滑动窗口：滑动窗口用于TCP流量控制，在接收方设置窗口的大小通知发送方，窗口是动态变化的，它受到网络拥塞情况以及接收方缓冲区剩余空间的限制。如果当前要发送的数据包的长度，大于窗口中的剩余空间，那这个数据包就会被拆分



## 解决方案

### 定长协议
每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要**空位补齐**

缺点：浪费字节和带宽

### 特殊字符分割
每次发送报文的尾部加上特定分隔符，接收方就可以根据特殊分隔符进行消息拆分。以下报文根据特定分隔符 **\n** 按行解析

缺点：分隔符的选择一定要避免和消息体中字符相同，以免冲突
### 变长协议
对于应用层的报文，可以将它分为报文头部以及报文体，而我们可以在报文头中指定当前报文中数据的长度，这样，接收方就能根据长度，正确地拆分多个粘在一起的数据了。


## 代码实现

### 编码
```Java
public class RpcEncoder extends MessageToByteEncoder<RpcProtocol<Object>> {  
  
    @Override  
    protected void encode(ChannelHandlerContext channelHandlerContext, RpcProtocol<Object> objectRpcProtocol, ByteBuf byteBuf) throws Exception {  
        MsgHeader header = objectRpcProtocol.getHeader();  
        byteBuf.writeShort(header.getMagic());  
        byteBuf.writeByte(header.getVersion());  
        byteBuf.writeByte(header.getSerialization());  
        byteBuf.writeByte(header.getMsgType());  
        byteBuf.writeByte(header.getStatus());  
        byteBuf.writeLong(header.getRequestId());  
        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(header.getSerialization());  
        //读取body的长度
        byte[] data = rpcSerialization.serialize(objectRpcProtocol.getBody()); 
        //将body的长度写入传输协议 
        byteBuf.writeInt(data.length);  
        byteBuf.writeBytes(data);  
    }  
}
```


### 解码
```Java
public class RpcDecoder extends ByteToMessageDecoder {  
    @Override  
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {  
        if (in.readableBytes() < ProtocolConstants.HEADER_TOTAL_LEN) {  
            return;  
        }  
        in.markReaderIndex();  
  
        short magic = in.readShort();  
        if (magic != ProtocolConstants.MAGIC) {  
            throw new IllegalArgumentException("magic number is illegal, " + magic);  
        }  
  
        byte version = in.readByte();  
        byte serializeType = in.readByte();  
        byte msgType = in.readByte();  
        byte status = in.readByte();  
        long requestId = in.readLong();  
  
        int dataLength = in.readInt();  
        if (in.readableBytes() < dataLength) {  
            in.resetReaderIndex();  
            return;  
        }  
        //读取body的长度值
        byte[] data = new byte[dataLength];  
        //从缓冲区中读取body长度的字节
        in.readBytes(data);
        }
}
```
## 总结
TCP可以保证完整，并且**按序地接收字节**，但是并不会帮忙拆分多个包的字节，真正做这个工作的是**应用层的协议**，应用层负责解决粘包和拆包。

