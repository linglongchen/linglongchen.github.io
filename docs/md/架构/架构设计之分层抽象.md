

## 背景
最近梳理菜鸟相关应用的架构和链路，梳理下来有一些相关的心得记录一下。主要记录对于他们架构的设计和抽象的使用。



## 分层抽象

### 分层

在梳理菜鸟系统架构中，分层是经常使用的方式，也是使用的很合理的一种方式。

分层是架构设计中的基本思想，例如MVC就是经典的分层设计，分层可以让架构更直观的自顶向下展示架构的层级关系。


### 抽象
抽象是面向对象设计的基本要素，合理运用抽象可以让整个流程和链路更好的展示和使用。架构设计中的边界就是通过抽象划分出来的，因此抽象是检验架构师的基础能力。

抽象的部分不应该总是发生变更



### 实践设计

单一职责用于奠定架构边界；
开闭原则对易于扩展、限制被修改。不同的processor就是用于扩展，抽象的processor避免被修改
架构师应该将可变和不可变隔离，二方包的应该是尽量不可变的流程，如果经常可变就会导致每次修改都需要进行编译，对于没有修改到的代码做编译和部署是有害的。

final的使用，在抽象类的方法上使用final可以将不需要子类实现的方法隔离。
学会封装复杂类，比如将抽象类、接口封装到一个类中。
操作数据库的模块要与业务逻辑隔离。
服务拆分是为了隔离可变流程和不可变流程，将可变流程独立为一个服务，不可变流程独立为一个服务实现降低发布、部署的频率和改动点


#### 抽象基类
```java
public interface BizProcessor<T extends BaseContext> {  
  
    /**  
     * 业务处理  
     * @param context  
     * @return  
     */  
    void process(T context);  
}
```

使用接口定义需要实现的基本方法，该方法是最高级的抽象方法。
#### 抽象业务流程
```java
public abstract class AbstractProcessor<T> implements BizProcessor<BizContext<T>> {  
  
    protected abstract void parseParams(BizContext<T> context);  
  
  
    protected abstract void checkParams(BizContext<T> context);  
  
    protected abstract void prepareData(BizContext<T> context);  
  
    protected abstract void processData(BizContext<T> context);  
  
    protected abstract void doProcess(BizContext<T> context);  
  
    protected abstract void afterProcess(BizContext<T> context);  
  
    protected abstract void saveData(BizContext<T> context);  
  
    protected abstract void buildResponse(BizContext<T> context);  
  
}
```

使用抽象类抽象基本业务实现，并且实现接口

#### 抽象业务链路

下发链路

```java
public abstract class AbstractNotifyBizProcessor extends AbstractProcessor<Response> {  
  
    /**  
     * 业务处理:使用模版方法，定义业务处理的流程，具体的业务处理由子类实现  
     * @param context  
     * @return  
     */  
    @Override  
    public void process(BizContext<Response> context) {  
        this.parseParams(context);  
  
        this.checkParams(context);  
  
        this.prepareData(context);  
  
        this.processData(context);  
  
        this.doProcess(context);  
  
        this.afterProcess(context);  
  
        this.saveData(context);  
  
        this.buildResponse(context);  
    }  
  
    public abstract String processName();  
  
}
```


回传链路
```java
public abstract class AbstractCallbackBizProcessor extends AbstractProcessor<Response> {  
  
    /**  
     * 业务处理:使用模版方法，定义业务处理的流程，具体的业务处理由子类实现  
     * @param context  
     * @return  
     */  
    @Override  
    public void process(BizContext<Response> context) {  
        this.parseParams(context);  
  
        this.checkParams(context);  
  
        this.prepareData(context);  
  
        this.processData(context);  
  
        this.doProcess(context);  
  
        this.afterProcess(context);  
  
        this.saveData(context);  
  
        this.buildResponse(context);  
    }  
  
    public abstract String processName();  
  
}
```

#### 定义核心流程

```java
public abstract class AbstractBizService<R,K> {  
  
    @Resource  
    private AbstractProcessorFactory abstractProcessorFactory;  
  
  
    /**  
     * 对外的执行逻辑  
     * @param request  
     * @return  
     */  
    public final ResultDTO<R> execute(K request) {  
        this.preCheckRequest(request);  
  
        BizContext context = this.buildContext(request);  
  
        this.doExecute(context);  
  
        return this.buildResult(context);  
    }  
  
  
    public abstract void preCheckRequest(K request);  
  
    public abstract BizContext buildContext(K request);  
  
    private void doExecute(BizContext context) {  
        AbstractProcessor processor = abstractProcessorFactory.getProcessor(context.getProcessName());  
        processor.process(context);  
    }  
  
  
    public abstract ResultDTO<R> buildResult(BizContext context);  
}
```






