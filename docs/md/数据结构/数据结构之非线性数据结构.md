

## 哈希表

### 特性
- 哈希表的结构可以类比数组，数组中通过索引index找到具体元素，把数组的每个元素看成一个bucket，每个bucket可以存储键值对
- 在哈希表中，输入空间是所有 key ，输出空间是所有桶（数组索引）。换句话说，输入一个 key ，我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置
- index = hash(key) % capacity
- **哈希表扩容**：类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容
- **负载因子**：哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过   
 0.8时，系统会将哈希表扩容至原先的2倍。


### 哈希冲突
#### 链式地址
将桶中的键值对改为链表，链表中存储哈希冲突的键值对，当寻址发生哈希冲突时，找到对应的桶，然后再遍历链表对比key得到value。


![.drawio.png](https://s2.loli.net/2024/08/18/fXbYa3seG21ATNw.png)

缺点：链表很长时会出现时间复杂度变高的情况，因此对于链表太长时需要转换为红黑树或者平衡二叉树

#### 开放寻址
##### 线性探测
- 通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为   
 ），直至找到空桶，将元素插入其中。
 
 - 线性探测容易产生“聚集现象”。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。
 
 - 值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在
##### 平方探测
##### 多次哈希
哈希函数 f1出现冲突，则尝试 f2，以此类推，直到找到空位后插入元素。
与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。

Java 采用链式地址。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。
Python 采用开放寻址。字典 dict 使用伪随机数进行探测。



### 哈希算法

哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值，进而决定了键值对在哈希表中的分布情况


#### 设计方案
- 加法哈希：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。
- 乘法哈希：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。
- 异或哈希：输入数据的每个元素通过异或操作累积到一个哈希值中。
- 旋转哈希：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作

#### 大质数

每个哈希设计方案中都会使用**1000000007**取模，这样是为了通过大的质数可以最大化的将哈希值均匀分布

为什么使用大质数？
- 因为质数不与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突

#### 常见哈希算法
- MD5
- SHA-1
- SHA-2
- SHA-3


## 树

### 二叉树

#### 特性
- 非线性数据结构
- 根节点和左右子树
- 二叉树退化：二叉树的节点都偏向一侧时会退化为链表

#### 二叉树遍历


##### 广度遍历
通过队列实现

```Java
/* 层序遍历 */
List<Integer> levelOrder(TreeNode root) {
    // 初始化队列，加入根节点
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    // 初始化一个列表，用于保存遍历序列
    List<Integer> list = new ArrayList<>();
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll(); // 队列出队
        list.add(node.val);           // 保存节点值
        if (node.left != null)
            queue.offer(node.left);   // 左子节点入队
        if (node.right != null)
            queue.offer(node.right);  // 右子节点入队
    }
    return list;
}
```

##### 深度遍历

###### 前序遍历:根左右
```Java
/* 前序遍历 */
void preOrder(TreeNode root) {
    if (root == null)
        return;
    // 访问优先级：根节点 -> 左子树 -> 右子树
    list.add(root.val);
    preOrder(root.left);
    preOrder(root.right);
}
```
###### 中序遍历:左根右
```Java
/* 中序遍历 */
void inOrder(TreeNode root) {
    if (root == null)
        return;
    // 访问优先级：左子树 -> 根节点 -> 右子树
    inOrder(root.left);
    list.add(root.val);
    inOrder(root.right);
}
```
###### 后续遍历:左右根

```Java
/* 后序遍历 */
void postOrder(TreeNode root) {
    if (root == null)
        return;
    // 访问优先级：左子树 -> 右子树 -> 根节点
    postOrder(root.left);
    postOrder(root.right);
    list.add(root.val);
}
```


### 完全二叉树
只有最底层的节点未被填满，且最底层节点尽量靠左填充

![-.jpg](https://s2.loli.net/2024/08/18/x78pArKzWmyoPvk.jpg)



### 二叉搜索树
- 对于根节点，左子树中所有节点的值 **<** 根节点的值 **<** 右子树中所有节点的值
- 二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况
- 二叉搜索树的中序遍历序列是升序的
- 二叉搜索树如果节点偏向一方，则会退化为链表


![-.jpg](https://s2.loli.net/2024/08/18/wl8Ehb4QTI61kHn.jpg)


### 平衡二叉树
- 满足Ologn的时间复杂度
- 左右子树的差值**不大于1**，保证不会退化为链表
- 平衡二叉树旋转（为了保证二叉树的左右子树的高度，不会退化）
	- 右旋
	- 左旋
	- 先左旋后右旋
	- 先右旋后左旋


![-.jpg](https://s2.loli.net/2024/08/18/182Oj9hTmdKIskr.jpg)
### B树
- 多路查找树，一种多叉树
- 一般用于文件查询或者数据库


#### 特性
- 所有键值分布在整个树中，每个节点都会存储键值
- 任何关键字出现且只出现在一个节点中
- 搜索有可能在非叶子节点结束
- 在关键字全集内做一次查找，性能逼近二分查找算法


(图片来源网络)
![po_diagram.png](https://s2.loli.net/2024/08/18/fpwYWHxrJ3Nb5XP.png)

### B+树
- 多路查找树
- 一般用于数据库索引
- 非叶子节点不存储数据，只存储key
- 所有的值都存储在叶子节点，所有叶子节点连接成为一个单链表，且这个链表是有序的
- 非叶子节点相当于是叶子节点的索引，叶子节点相当于是存储数据的数据层


(图片来源网络)
![po_diagram2.png](https://s2.loli.net/2024/08/18/IYo9ph48FWaBQGX.png)
为什么mysql用B+树?
- 适合范围查询
- 查询效率稳定，查询的数据都是需要遍历到叶子节点获取到最终的值
- 一次读取的范围更大，IO的次数更低


### 红黑树

- 平衡二叉树为了维护绝对的平衡会进行多次的旋转操作，在性能上会有一定的限制，红黑树可以减少旋转的次数，提高性能
#### 特点
- 根节点是黑的；
- 每个节点非红即黑
- 叶子节点都是黑的
- 如果一个节点是红的,那么它的两儿子都是黑的；
- 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点
- 高度始终保持在h = logn
![po_diagram3.png](https://s2.loli.net/2024/08/18/6SLOENdz9GU13Ms.png)


```Java
public class RedBlackBST<T> {  
    private static final boolean RED = true;  
    private static final boolean BLACK = false;  
    private Node<T> root;  
    private int size(Node<T> h){  
        return h.left.N + h.right.N;  
    }  
  
    public void put(T key,T val){  
        root = put(root,key,val);  
        root.color = BLACK;  
    }  
  
    public Node put(Node h,T key,T val) {  
        if (h == null) {  
            return new Node(key,val,1,RED);  
        }  
        //左旋成立的条件  
        if (isRed(h.right) && !isRed(h.left)) {  
            h = rotateLeft(h);  
        }  
        //右旋成立的条件  
        if (isRed(h.left) && isRed(h.left.left)) {  
            h = rotateRight(h);  
        }  
        //颜色转换条件  
        if (isRed(h.left) && isRed(h.right)) {  
            flipColor(h);  
        }  
        h.N = size(h.left) + size(h.right) + 1;  
        return h;  
    }  
    private Node<T> rotateLeft(Node<T> h) {  
        Node x = h.right;  
        h.right = x.left;  
        x.left = h;  
        x.color = h.color;  
        h.color = RED;  
        x.N = h.N;  
        h.N = 1+ size(h.left) + size(h.right);  
        return x;  
    }  
  
    private Node<T> rotateRight(Node<T> h) {  
        Node x = h.left;  
        h.left = x.right;  
        x.right = h;  
        x.color = h.color;  
        h.color = RED;  
        x.N = h.N;  
        h.N = 1+ size(h.left) + size(h.right);  
        return x;  
    }  
  
    private void flipColor(Node h) {  
        h.color = RED;  
        h.left.color = BLACK;  
        h.right.color = BLACK;  
    }  
  
    private boolean isRed(Node x) {  
        if (x == null) {  
            return false;  
        }  
        return x.color == RED;  
    }  
  
    @Data  
    private class Node<T> {  
        T key;  
        T value;  
        Node<T> left,right;  
        int N;  
        boolean color;  
        Node(T key,T value,int N,boolean color) {  
            this.key = key;  
            this.value = value;  
            this.N = N;  
            this.color = color;  
        }  
  
  
    }  
}
```
## 堆
- 是一种满足特定条件的完全二叉树
- 堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列
- 堆的实现，可以通过数组实现优先堆：
	- 从i节点找父节点：(i-1)/2
	- 从i节点找左子节点：2i+1
	- 从i节点找右子节点：2i+2

#### 类型
- 小顶堆：任意节点的值小于其它子节点
- 大顶堆：任意节点的值大于其它子节点


#### 入堆
（从底向上）从底部开始进入，和父节点比较，（以大顶堆为例）如果大于父节点则与父节点交换，交换节点后继续循环，直到当前节点小于父节点


```Java
public void shitUp(int index) {
        while (true) {
            //获取当前节点的父节点索引
            int parentIdx = parent(index);
            int parentData = data[parentIdx];
            int curData = data[index];
            if(parentIdx < 0 || curData <= parentData) {
                break;
            }
            swap(index,parentIdx);
            index = parentIdx;
        }
}
```


#### 移除堆顶元素
（从上到下）先将堆顶和最右边的元素交换，然后移除最右边的元素(此时移除的就是堆顶元素)，然后从堆顶向下遍历，找到左右节点的最大值，然后交换堆顶和左右子节点的数据。

```Java
public void shitDown(int index) {
        while (true) {
            int leftIdx = leftChild(index);
            int rightIdx = rightChild(index);
            int max = index;
            if (leftIdx < size && data[leftIdx] > data[max]) {
                max = leftIdx;
            }
            if (rightIdx < size && data[rightIdx] > data[max]) {
                max = rightIdx;
            }
            if (max == index) {
                break;
            }
            swap(index,max);
            index = max;
        }
}
```

